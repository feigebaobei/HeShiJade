<section class="content-box">
    <h1>当前支持的setter</h1>
    <ul>
        <li>input</li>
        <li>select</li>
        <li>switch</li>
        <li>options</li>
        <li>number</li>
    </ul>
    <p>select的value的类型是string</p>
    <p>options的value的类型是string</p>
    <h1>零代码与低代码的边界</h1>
    <p>零代码：</p>
    <ul>
        <li>定义：不写代码。</li>
        <li>落地点：为组件开辟若干配置项。经过配置后该组件可完成特定工作。</li>
        <li>优点：简单。配置什么就有什么功能。</li>
        <li>缺点：功能不丰富。</li>
        <li>功能边界在配置项的数量。即使有考虑重载、笛卡尔积，也不会太多。</li>
        <li>适合简单明确的工作。</li>
    </ul>
    <p>低代码：</p>
    <ul>
        <li>定义：写少量代码。</li>
        <li>落地点：1.使用模板、区块。2.使用一行命令生成大段代码。3.只写其中一小段代码。</li>
        <li>优点：比配置项灵活。</li>
        <li>缺点：必须遵守既定规范。</li>
        <li>它的功能边界由它的基座决定。</li>
        <li>可以比较严格的开发规范的开发团队。团队内有足够多沉淀。有一个运行代码片段的基座。</li>
    </ul>
    <p>在这个该平台项目中，代码量从富代码先降级为零代码，然后因零代码不足够灵活所以再升级为低代码。低代码主要在处理事件回调上发力。</p>
    <p>二者的边界在是否写代码。若不写代码则是零代码，否则是低代码。低代码平台把组件的功能抽象为配置项，无法抽象事件，事件太灵活了。事件需要明确在什么情况下触发什么逻辑。若处理为配置逻辑则太复杂。所以低代码平台只开辟一个事件名，则搭建者编写回调方法。</p>
    <h1>低代码与富代码的边界</h1>
    <p>低代码</p>
    <ul>
        <li>定义：写少量代码。</li>
        <li>落地点：1.使用模板、区块。2.使用一行命令生成大段代码。3.只写其中一小段代码。</li>
        <li>优点：迭代快。</li>
        <li>缺点：必须按照从富代码沉淀来的逻辑运行。</li>
        <li>沉淀了富代码开发流程中的规范，整理常用的功能，抽象为通用功能。必须是：一次开发，多次使用。</li>
        <li>要考虑复用率。开发一个尽可能广的基座，让组件或插件在其上运行。充分考虑组件的通用性、复用性才去开发。开发时配置项足够简单，要求组件内足够内聚。</li>
        <li>开发一个低代码组件的成本是富代码的3-5倍。</li>
    </ul>
    <p>富代码</p>
    <ul>
        <li>定义：写全量代码。</li>
        <li>落地点：全部</li>
        <li>优点：很灵活、很全面。</li>
        <li>缺点：迭代慢。需要规范的开发流程。</li>
        <li>仍是绝大部分项目的方式。富代码范围内有好多种开发规范。</li>
        <li>要考虑工程化（规范化、模块化、自动化）、团队配合。</li>
    </ul>
    <h1>判断能否使用低代码</h1>
    <p>判断是否使用低代码</p>
    <ul>
        <li>有任一功能（含降级后的功能）在低代码平台不满足</li>
        <li>有个性化的表现（如：ui样式/js逻辑）</li>
        <li>交互逻辑超过了低代码的能力</li>
        <li>与其他项目有结合时，（低代码不太好）</li>
    </ul>
    <ul>
        <li>页面交互简单</li>
        <li>功能单一</li>
        <li>要求迭代快</li>
    </ul>
    <p></p>
</section>